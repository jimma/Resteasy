<chapter id="JAX-RS_2.1_additions">
    <title>JAX-RS 2.1 Additions</title>
    <para>JAX-RS 2.1 adds more asynchronous processing support in both the
        Client and the Server API.  The specification adds a Reactive programming
        style to the Client side and Server-Sent Events (SSE) protocol support to
        both client and server.
    </para>

    <sect1>
        <title>Rective Clients API</title>
        <para>The specification defines a new type of invoker named RxInvoker, and a default
            implementation of this type named CompletionStageRxInvoker.
            CompletionStageRxInvoker implements Java 8's interface CompletionStage.
            This interface declares a large number of methods dedicated to managing
            asynchronous computations.
        </para>
        <para>There is also a new rx method which is used in a similar manner to async.
        </para>
    </sect1>

    <sect1>
        <title>Server-Sent Events (SSE)</title>
        <para>
             SSE is a part of HTML standard and now it is supported by many browsers. 
             It is another server push technology, which provides a way to establish 
             a one-way channel to continuously send data to client. SSE event is pushed 
             to the client via a long-running HTTP connection and the client can automatically 
             reconnect to retrieve missed events after the connection is lost by set 
             a "Last-Event-ID" HTTP header in the request.
        </para>
        <para> 
             SSE stream has text/event-stream media type and it contains multiple SSE events. 
             SSE event is a data structure encoded with UTF-8 and contains fields and comment. 
             The field can be event, data, id, retry and other kinds of field will be ignored.
        </para>
        <para>
             From JAX-RS 2.1, Server-sent Events APIs are introduced to support send, receive and broadcast SSE event.
        </para>
        <sect2>
            <title>SSE Server</title>
            <para>
              Like the following example,  SSE resource method has the text/event-stream produce 
              media type and a injected context parameter SseEventSink. Injected SseEventSink is 
              the connected SSE stream where events can send. Another injected context Sse is an 
              entry point for creating event and broadcast SSE event. Here is an example to 
               demonstrate send SSE events every 200ms and close stream after the "done" event.             
            </para>
            <para>
            <example>
               <programlisting><![CDATA[
   @GET
   @Path("domains/{id}")
   @Produces(MediaType.SERVER_SENT_EVENTS)
   public void startDomain(@PathParam("id") final String id, @Context SseEventSink sink @Context Sse sse)
   {
      ExecutorService service = (ExecutorService) servletContext
            .getAttribute(ExecutorServletContextListener.TEST_EXECUTOR);
      service.execute(new Thread()
      {
         public void run()
         {
            try
            {
               sink.send(sse.newEventBuilder().name("domain-progress")
                     .data(String.class, "starting domain " + id + " ...").build());
               Thread.sleep(200);
               sink.send(sse.newEvent("domain-progress", "50%"));
               Thread.sleep(200);
               sink.send(sse.newEvent("domain-progress", "60%"));
               Thread.sleep(200);
               sink.send(sse.newEvent("domain-progress", "70%"));
               Thread.sleep(200);
               sink.send(sse.newEvent("domain-progress", "99%"));
               Thread.sleep(200);
               sink.send(sse.newEvent("domain-progress", "Done.")).thenAccept((Object obj) -> {
                  sink.close();
               });
            }
            catch (final InterruptedException e)
            {
               logger.error(e.getMessage(), e);
            }
         }
      });
   }              
                ]]>
                </programlisting>
             </example>
            </para>
        </sect2>
        <sect2>
            <title>SSE Broadcasting</title>
            <para>
               With SseBroadcaster, SSE events can be broadcasted to multiple clients simultaneously. 
               It will iterate all registered SseEventSinks and send event to all requested SSE Stream.  
               An application can create SseBroadcaster from an injected context Sse.The broadcast 
               method on a SseBroadcaster is used to send SSE event to all registered clients.
               The following code snippet is an example to create SseBroadcaster, subscribe 
               and broadcast event to all subscribed consumers. 
            </para>
            <para>
            <example>
               <programlisting><![CDATA[
   @GET
   @Path("/subscribe")
   @Produces(MediaType.SERVER_SENT_EVENTS)
   public void subscribe(@Context SseEventSink sink) throws IOException
   {
      if (sink == null)
      {
         throw new IllegalStateException("No client connected.");
      }
      if (sseBroadcaster == null)
      {
         sseBroadcaster = sse.newBroadcaster();
      }
      sseBroadcaster.register(sink);
   }

   @POST
   @Path("/broadcast")
   public void broadcast(String message) throws IOException
   {
      if (sseBroadcaster == null)
      {
         sseBroadcaster = sse.newBroadcaster();
      }
      sseBroadcaster.broadcast(sse.newEvent(message));

   }          
                ]]>
                </programlisting>
             </example>
            </para>
        </sect2>
        <sect2>
            <title>SSE Client</title>
            <para>
                SseEventSource is the entry point to read and process incoming SSE event. 
                A SseEventSource instance can be initialized with a WebTarget. Once SseEventSource 
                is created and connected to a server, registered event consumer will be invoked when 
                an inbound event arrives. When there is error happens, the exception will be passed 
                to a registered consumer to process. SseEventSource can automatically reconnect server 
                and continuously receive pushed events after the connection is lost. SseEventSource 
                can send lastEventId to server by default when it is reconnected, and server may use 
                this id to replay all missed events. But reply event is really upon on SSE resource 
                method implementation.  If the server responds HTTP 503 with a RETRY_AFTER header, 
                SseEventSource will automatically schedule a  reconnect task with this RETRY_AFTER 
                value. The following code snippet is to create a SseEventSource and print the 
                inbound event data value and error if it happens.
            </para>
          <para>
            <example>
               <programlisting><![CDATA[
    public void printEvent() throws Exception
    {
      WebTarget target = client.target("http://localhost:8080/service/server-sent-events"));
      SseEventSource msgEventSource = SseEventSource.target(target).build();
      try (SseEventSource eventSource = msgEventSource)
      {
         eventSource.register(event -> {
            System.out.println(event.readData(String.class));
         }, ex -> {
            ex.printStackTrace();
         });
         eventSource.open();
      } 
    }   
                ]]>
                </programlisting>
             </example>
            </para>
        </sect2>
    </sect1>
    <sect1>
        <title>Java API for JSON Binding</title>
        <para>
            RESTEasy supports both JSON-B and JSON-P.  In accordance with the specification,
            entity providers for JSON-B take precedence over those for JSON-P for all types
            except JsonValue and its sub-types.
        </para>
    </sect1>
</chapter>
